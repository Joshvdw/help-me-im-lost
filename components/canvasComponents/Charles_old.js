/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import * as THREE from 'three'
import { useFrame } from '@react-three/fiber'
import { useSpring, config } from "@react-spring/three";

export function Charles(props) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/glbs/Charles.glb')
  const { actions } = useAnimations(animations, group)


  // SIMPLE SCROLL-BASED KEYFRAME ANIMATIONS 
  // 1: need to set the animation to paused initially to work
  // useEffect(() => {
  //   actions['stumble'].play().paused = true;
  // }, [])

  // // 2: update the animation's time every frame by the clip duration * normalised value of scroll position
  // useFrame(() => {
  //   actions['stumble'].time = actions['stumble'].getClip().duration * window.scrollY / (document.body.offsetHeight - window.screen.availHeight)
  // }) 

  // SCROLL-BASED ANIMATION WITH USE-SPRING
  // 1: need to set the animation to paused initially to work
  useEffect(() => {
    actions['stumble'].play().paused = true;
  }, [])

  // 2: declaring custom useSpring configuration options
  const options = {
    mass: 1,
    tension: 260,
    friction: 100,
    precision: 0.0000001,
    velocity: 2,
    clamp: true,  
  }

  // 3: initialising the y value of the spring, created a set function called setScroll to update the y
  const [{ y }, setScroll] = useSpring(()=> ({
    y: [0],
    config: options
  }))

  // 4: function to set the scroll value of y to the normalised value of the user's scroll position 
  const handleScroll = () => {
    setScroll({
      y: [window.scrollY / (document.body.offsetHeight - window.screen.height)]
    })
  }

  // 5: when the user scrolls, call the handleScroll function
  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    // removing the scroll event listener after handle
    return () => window.removeEventListener("scroll", handleScroll);
  }, [handleScroll])

  // 6: set the time of the animation to be the length of the clip * the normalised useSpring value (y)
  useFrame(() => {
    y.to((y) => {
      actions['stumble'].time = actions['stumble'].getClip().duration * y
    })
  })
//     const materialNew = new THREE.RawShaderMaterial({
//     vertexShader: `

// precision highp float;
// precision highp int;

// uniform mat4 modelMatrix;
// uniform mat4 modelViewMatrix;
// uniform mat4 projectionMatrix;
// uniform mat4 viewMatrix;
// uniform mat3 normalMatrix;
// uniform float uTest;

// attribute vec3 position;
// attribute vec3 normal;
// attribute vec2 uv;
// attribute vec2 uv2;

// varying vec2 vUv;
// varying vec3 vPosition;
// varying vec3 vNormal;

// void main() {
//   vUv = uv;
//   vPosition = position;
//   vNormal = normal;
//   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
// }`,
//     fragmentShader: `
// // http://glslsandbox.com/e#11554.0

// #ifdef GL_ES
// precision mediump float;
// #endif

// uniform float time;

// varying vec2 vUv;
// varying vec3 vPosition;
// varying vec3 vNormal;

// // by @301z

// float rand(vec2 n) { 
// 	return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
// }

// float noise(vec2 n) {
// 	const vec2 d = vec2(0.0, 1.0);
// 	vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
// 	return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
// }

// float fbm(vec2 n) {
// 	float total = 0.0, amplitude = 1.0;
// 	for (int i = 0; i < 7; i++) {
// 		total += noise(n) * amplitude;
// 		n += n;
// 		amplitude *= 0.5;
// 	}
// 	return total;
// }

// void main() {
// 	const vec3 c1 = vec3(0.1, 0.0, 0.0);
// 	const vec3 c2 = vec3(0.7, 0.0, 0.0);
// 	const vec3 c3 = vec3(0.2, 0.0, 0.0);
// 	const vec3 c4 = vec3(1.0, 0.9, 0.0);
// 	const vec3 c5 = vec3(0.1);
// 	const vec3 c6 = vec3(0.9);
// 	vec2 p = vUv.xy * 8.0;
// 	float q = fbm(p - time * 0.1);
// 	vec2 r = vec2(fbm(p + q + time * 0.7 - p.x - p.y), fbm(p + q - time * 0.4));
// 	vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);
// 	gl_FragColor = vec4(c * cos(1.57 * vUv.y), 1.0);
// }
// `  
//   })

  //   const hatGeo = nodes.mixamorigHat_Geo.geometry;
  // const headGeo = nodes.mixamorigHead_Geo.geometry
  // const hatMesh = new THREE.Mesh(hatGeo, materialNew)
  // const headMesh = new THREE.Mesh(headGeo, materialNew)
  

  return (
    <>
      {/* <primitive object={hatMesh}></primitive> */}
    {/* <primitive object={headMesh}></primitive> */}
    <group ref={group} {...props} dispose={null} scale={2} position={[2,-2,0]}>
      <group name="Scene">
        <group name="mixamorigMeshes" rotation={[Math.PI / 2, 0, 0]} scale={0.01} />
        <group name="Charles" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <primitive object={nodes.mixamorigHips} />
          <skinnedMesh name="mixamorigArms_Geo" geometry={nodes.mixamorigArms_Geo.geometry} material={materials.Skin_MAT} skeleton={nodes.mixamorigArms_Geo.skeleton} />
          <skinnedMesh name="mixamorigCigar_Geo" geometry={nodes.mixamorigCigar_Geo.geometry} material={materials.Cigar_Mat} skeleton={nodes.mixamorigCigar_Geo.skeleton} />
          <skinnedMesh name="mixamorigHat_Geo" geometry={nodes.mixamorigHat_Geo.geometry} material={materials['Clothes_MAT.001']} skeleton={nodes.mixamorigHat_Geo.skeleton} />
          <skinnedMesh name="mixamorigHead_Geo" geometry={nodes.mixamorigHead_Geo.geometry} material={materials.Skin_MAT} skeleton={nodes.mixamorigHead_Geo.skeleton} />
          <skinnedMesh name="mixamorigJacket_Geo" geometry={nodes.mixamorigJacket_Geo.geometry} material={materials.Clothes_MAT} skeleton={nodes.mixamorigJacket_Geo.skeleton} />
          <skinnedMesh name="mixamorigL_Eye_Geo" geometry={nodes.mixamorigL_Eye_Geo.geometry} material={materials['Eyes_MAT.001']} skeleton={nodes.mixamorigL_Eye_Geo.skeleton} />
          <skinnedMesh name="mixamorigPants_Geo" geometry={nodes.mixamorigPants_Geo.geometry} material={materials['Clothes_MAT.001']} skeleton={nodes.mixamorigPants_Geo.skeleton} />
          <skinnedMesh name="mixamorigR_Eye_Geo" geometry={nodes.mixamorigR_Eye_Geo.geometry} material={materials.Eyes_MAT} skeleton={nodes.mixamorigR_Eye_Geo.skeleton} />
          <skinnedMesh name="mixamorigShoes_Geo" geometry={nodes.mixamorigShoes_Geo.geometry} material={materials['Clothes_MAT.001']} skeleton={nodes.mixamorigShoes_Geo.skeleton} />
          <skinnedMesh name="mixamorigTeeth_Down_Geo" geometry={nodes.mixamorigTeeth_Down_Geo.geometry} material={materials.Skin_MAT} skeleton={nodes.mixamorigTeeth_Down_Geo.skeleton} />
          <skinnedMesh name="mixamorigTeeth_Up_Geo" geometry={nodes.mixamorigTeeth_Up_Geo.geometry} material={materials.Skin_MAT} skeleton={nodes.mixamorigTeeth_Up_Geo.skeleton} />
        </group>
      </group>
    </group>
    </>
  )
}

useGLTF.preload('/glbs/Charles.glb')
